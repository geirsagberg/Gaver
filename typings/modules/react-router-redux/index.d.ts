// Generated by typings
// Source: https://raw.githubusercontent.com/andrew-w-ross/typings-history/master/history.d.ts
declare module '~react-router-redux~history' {
module otherHistory {
	type Action = 'PUSH' | 'REPLACE' | 'POP';

	type BeforeUnloadHook = () => string | void;

	type CreateLocation = (path: string, locationObj: Object) => Location;

	type CreateHistoryDefault = CreateHistory<HistoryOptions, History>;

	type CreateHistory<TOptions extends HistoryOptions, TResult extends History> = (options?: TOptions) => TResult;

	type Hash = string;

	interface History {
		listenBefore(hook: TransitionHook): Function;
		listen(listener: LocationListener): Function;
		transitionTo(location: Location): void;
		push(location: LocationDescriptor): void;
		replace(location: LocationDescriptor): void;
		go(n: number): void;
		goBack(): void;
		goForward(): void;
		createKey(): LocationKey;
		createLocation: CreateLocation;
		createPath(location: LocationDescriptor): Path;
		createHref(location: LocationDescriptor): Href;
	}

	interface HistoryOptions {
		getUserConfirmation?(message: string, callback: (confirmed: boolean) => void): void;
		queryKey?: boolean | string;
	}

	interface BeforeUnload {
		listenBeforeUnload?(callBack: () => string | boolean | void): void;
	}

	interface QueryOptions {
		parseQueryString?(queryString: string): any;
		stringifyQuery?(query: Object): string;
	}

	interface BasenameOptions {
		basename?: string;
	}

	type Href = string;

	interface Location {
		pathname?: Pathname;
		search?: Search;
		query?: Query;
		state?: LocationState;
		action?: Action;
		key?: LocationKey;
	}

	interface LocationDescriptorObject {
		pathname?: Pathname;
		search?: Search;
		query?: Query;
		state?: LocationState;
	}

	type LocationDescriptor = LocationDescriptorObject | Path;

	type LocationKey = string;

	type LocationListener = (location: Location) => void;

	type LocationState = Object;

	type Path = string;

	type Pathname = string;

	type Query = Object;

	type Search = string;

	type TransitionHook = (location: Location, callback?: Function) => any;

	export const createLocation: CreateLocation;

	export const createHistory: CreateHistoryDefault;

	export const createHashHistory: CreateHistoryDefault;

	export const createMemoryHistory: CreateHistoryDefault;

	export function useBeforeUnload<TArguments, TResult extends History>(createHistory: CreateHistory<TArguments, TResult>): CreateHistory<TArguments, TResult & BeforeUnload>;

	export function useQueries<TArguments, TResult extends History>(createHistory: CreateHistory<TArguments, TResult>): CreateHistory<TArguments & QueryOptions, TResult>;

	export function useBasename<TArguments, TResult extends History>(createHistory: CreateHistory<TArguments, TResult>): CreateHistory<TArguments & BasenameOptions, TResult>;
}

export = otherHistory;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/andrew-w-ross/typings-redux/master/redux.d.ts
declare module '~react-router-redux~redux' {
module redux {
	//This should be extended
	export interface IAction {
		type: string | number;
	}

	export interface IActionGeneric<TPayload> extends IAction {
		payload?: TPayload;
		error?: Error;
		meta?: any;
	}

	export interface IReducer<TState> {
		(state: TState, action: IAction): TState;
	}

	export interface IReducerMap {
		[key: string]: IReducerMap | IReducer<any>
	}

	export interface IDispatch {
		(action: IAction): IAction;
	}

	export interface IMiddlewareStore<TState> {
		getState(): TState;

		dispatch: IDispatch;
	}

	export interface IStore<TState> extends IMiddlewareStore<TState> {
		subscribe(listener: (state: TState) => any): () => void;

		replaceReducer(nextReducer: IReducer<TState>): void;
	}

	export interface IMiddleware<State> {
		(middlewareStore: IMiddlewareStore<State>): (next: IDispatch) => IDispatch;
	}

	export interface ICreateStoreGeneric<TState> {
		(reducer: IReducer<TState>, initialState?: TState): IStore<TState>;
	}

	export interface IStoreEnhancerGeneric<TState> {
		(createStore: ICreateStoreGeneric<TState>): ICreateStoreGeneric<TState>;
	}

	export function createStore<TState>(reducer: IReducer<TState>, initialState?: TState): IStore<TState>;

	export function combineReducers(reducers: IReducerMap): IReducer<any>;
	export function combineReducers<TState>(reducers: IReducerMap): IReducer<TState>;

	export function applyMiddleware<TState>(...middlewares: IMiddleware<TState>[]): IStoreEnhancerGeneric<TState>;

	export function bindActionCreators<TActionCreator extends Function | { [key: string]: Function }>(actionCreators: TActionCreator, dispatch: IDispatch): TActionCreator;

	export function compose<TArg>(...functions: { (arg: TArg): TArg }[]): (arg: TArg) => TArg;
	export function compose(...functions: { (arg: any): any }[]): (arg: any) => any;
}

export = redux;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/andrew-w-ross/typings-react-router-redux/caf792cb79efbf54ce328366809dc52821192a73/react-router-redux.d.ts
declare module 'react-router-redux' {

import {History, Location, LocationDescriptor} from '~react-router-redux~history';
import {IMiddleware, IStore, IAction, IReducer} from '~react-router-redux~redux';

module reactRouterRedux {    
    /**
     * An action type that you can listen for in your reducers to be notified of route updates. Fires after any changes to history.
     */
    export const LOCATION_CHANGE: string;
    
    /**
     * Router action
     */
    export interface RouterAction extends IAction {
        /**
         * New location
         */
        payload: Location;
    }

    /**
     * Redux router internal state. Useful if you're overriding own reducer
     */
    export interface IRouterState {
        locationBeforeTransitions: Location;
    }
    
    /**
     * History syncing options
     */
    interface ISyncHistoryOptions<TState> {
        /**
         * When false, the URL will not be kept in sync during time travel. 
         * This is useful when using persistState from Redux DevTools and not wanting to maintain the URL state when restoring state.
         * @default true
         */
        adjustUrlOnReplay?: boolean;
        /**
         * A selector function to obtain the history state from your store. 
         * Useful when not using the provided routerReducer to store history state. Allows you to use wrappers, such as Immutable.js.
         * @default state => state.routing
         */
        selectLocationState?: (state: TState) => IRouterState;
    }
    
    /**
     * @export
     * @template TState
     * @param {History} history History singleton from react-router
     * @param {IStore<TState>} store Application store
     * @param {ISyncHistoryOptions<TState>} options Syncing options
     */
    export function syncHistoryWithStore<TState>(history: History, store: IStore<TState>, options?: ISyncHistoryOptions<TState>): History;

	/**
	 * A reducer function that keeps track of the router state. You must add this reducer to your app reducers when creating the store. 
	 * It will return a location property in state. If you use combineReducers, it will be nested under wherever property you add it to (state.routing in the example above).
	 * Warning: It is a bad pattern to use react-redux's connect decorator to map the state from this reducer to props on your Route components. This can lead to infinite loops and performance problems. react-router already provides this for you via this.props.location.
	 * 
	 * @export
	 * @param {Location} state (description)
	 * @param {IAction} action (description)
	 * @returns {Location} (description)
	 */
	export function routerReducer(state: IRouterState, action: RouterAction): IRouterState;
    
        
    /**
     * A middleware you can apply to your Redux store to capture dispatched actions created by the action creators. 
     * It will redirect those actions to the provided history instance.
     */
    export function routerMiddleware<TState>(history: History): IMiddleware<TState>;
    
    // Action types interfaces. These are deprecated
    /**
     * @deprecated
     */
    interface IRoutePushAction {
        (nextLocation: LocationDescriptor): IAction;
    }
    
    /**
     * @deprecated
     */
    interface IRouteReplaceAction {
        (nextLocation: LocationDescriptor): IAction;
    }
    
    /**
     * @deprecated
     */
    interface IRouteGoAction {
        (n: number): IAction;
    }
    
    /**
     * @deprecated
     */
    interface IRouteGoForwardAction {
        (): IAction;
    }
    
    /**
     * @deprecated
     */
    interface IRouteGoBackAction {
        (): IAction;
    }

    /**
     * @deprecated
     */
	export interface IRouteActions {
		push: IRoutePushAction;
		replace: IRouteReplaceAction;
		go: IRouteGoAction;
		goForward: IRouteGoForwardAction;
		goBack: IRouteGoBackAction;
	}

	/**
	 * An object that contains all the actions creators you can use to manipulate history:
	 * @deprecated
	 * @export
	 */
	export const routerActions: IRouteActions;
    
    /**
     * This action type will be dispatched by the history actions below.
     * If you're writing a middleware to watch for navigation events, be sure to
     * look for actions of this type.
     * @export
     */
    export const CALL_HISTORY_METHOD: string;
    
    // separate actions
    /**
     * @deprecated
     */
    export const push: IRoutePushAction;
    /**
     * @deprecated
     */
    export const replace: IRouteReplaceAction;
    /**
     * @deprecated
     */
    export const go: IRouteGoAction;
    /**
     * @deprecated
     */
    export const goForward: IRouteGoForwardAction;
    /**
     * @deprecated
     */
    export const goBack: IRouteGoBackAction;

}

export = reactRouterRedux;
}
